<!DOCTYPE html>
<html>
  <head>
    <title>3cPingPong</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body style="margin:0px">
    <h1 id="player" style="position: absolute;
    top: 10px;
    width: 100%;
    text-align: left;
    z-index: 100;
    display:block;
    color:azure">3colorPingPong</h1>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
      const COLOR1 =0xff0000;
      const COLOR2 =0x00ff00;
      const COLOR3 =0x0000ff;
      const TABLE_COLOR=0xffffff;
      const TABLE_WIDTH=12;
      const TABLE_HEIGHT=14;
      const BALL_COLOR = COLOR2;
      const PADDLE_1_COLOR = COLOR1;
      const PADDLE_2_COLOR = COLOR3;
      
    </script>
    
    <script type="module">
      const socket = io();
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      const scene = new THREE.Scene();
      scene.rotation.set(-70*(Math.PI/180),0,0);

      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0,0,12);
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);

      document.body.appendChild(renderer.domElement);

      const geometryTable = new THREE.BoxGeometry(TABLE_WIDTH,TABLE_HEIGHT,0);
      const geometryBall = new THREE.SphereGeometry(1, 30, 30);
      const geometryBox = new THREE.BoxGeometry(2, 0.25, 0.25);

      const materialTable = new THREE.MeshBasicMaterial({ color: TABLE_COLOR });
      const materialBall = new THREE.MeshBasicMaterial({ color: BALL_COLOR });
      const materialBox = new THREE.MeshBasicMaterial({ color: PADDLE_1_COLOR});
      const materialBox2 = new THREE.MeshBasicMaterial({ color: PADDLE_2_COLOR});

      const table = new THREE.Mesh(geometryTable, materialTable);
      table.position.set(0, 0, -0.20);
      scene.add(table);

      const paddleA = new THREE.Mesh(geometryBox, materialBox);
      paddleA.position.set(0, -7, 0);
      scene.add(paddleA);

      const paddleB = new THREE.Mesh(geometryBox, materialBox2);
      paddleB.position.set(0, 7, 0);
      scene.add(paddleB);

      const ball = new THREE.Mesh(geometryBall, materialBall);
      ball.position.set(0, 0, 0);
      ball.scale.set(0.25, 0.25, 0.25);
      scene.add(ball);
      
  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      var thisPlayer="";
      var gamesStart = false;
      var senX=-1;
      var senY=-1;
      var ballSpeedX = 0.05;
      var ballSpeedY = 0.05;

      function moveBall(){  
        if(!gamesStart) return;
        var ballX = ball.position.x;
        var ballY = ball.position.y;
  
        if (ballX > TABLE_WIDTH/2 || ballX < -TABLE_WIDTH/2 ) {
          senX = -senX;
        }

        if(ballY>TABLE_HEIGHT+1/2){
          ballSpeedY=0.04;
          ball.position.set(0, 0, 0);
          socket.emit("resetPoint",senY);
        }

        if(ballY<-TABLE_HEIGHT+1/2){
          ballSpeedY=0.04;
          ball.position.set(0, 0, 0);
          socket.emit("resetPoint",senY);
        }

        // Check for collisions with the paddles
        if (ballY > paddleA.position.y - 0.5 && ballY < paddleA.position.y + 0.5 && ballX > paddleA.position.x - 1 && ballX < paddleA.position.x + 1) {
            senY = 1;
            ballSpeedX+=0.001;
            ball.position.set(ball.position.x, -6, 0);
            socket.emit("color","");
        }
        if(ballY > paddleB.position.y - 0.5 && ballY < paddleB.position.y + 0.5 && ballX > paddleB.position.x - 1 && ballX < paddleB.position.x + 1){
            senY = -1;
            ballSpeedY+=0.001;
            ball.position.set(ball.position.x, 6, 0);
            socket.emit("color","");
        }  
          // Move the ball to its new position
          ball.position.x += (ballSpeedX*senX);
          ball.position.y += (ballSpeedY*senY);
      }

      function animate() {
          requestAnimationFrame(animate);
          moveBall();
          renderer.render(scene, camera);
      }

   //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

      function movePaddle(event) {
          var mouseX = event.clientX / window.innerWidth * 10 - 5;
          if (mouseX > 6)  mouseX = 6;

          if(thisPlayer=="Player2"){
            paddleB.position.x=-mouseX;
            socket.emit("paddleBPos",paddleB.position.x);
          }else{
            paddleA.position.x=mouseX;
            socket.emit("paddleAPos",paddleA.position.x);
          } 
      }

      window.addEventListener('touchstart', function(event) {
        clientX = e.touches[0].clientX;
      });

       window.addEventListener('mousemove', function(event) {
          movePaddle(event);
      });

      window.addEventListener('resize', function() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
      });

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      

      socket.on('join', msg => {
        alert(msg);
        if(msg=="player2"){
          scene.rotation.set(-70*(Math.PI/180),0,Math.PI);
          thisPlayer="Player2"
        }else thisPlayer="Player1";
        document.getElementById("player").innerText=thisPlayer;
      });

      socket.on('start', msg => {
        gamesStart=true;
        senX=-1;
        senY=-1;
        ballSpeedX=0.05;
        ballSpeedY = 0.05;
        animate();
      })

      socket.on('pause', msg => {
        alert("pause");
        location.href = window.location.href;
        gamesStart=false;
        animate();
      });

      socket.on('paddleAPos', msg => {
        paddleA.position.x=msg;
      }); 

      socket.on('paddleBPos', msg => {
        paddleB.position.x=msg;
      }); 

      socket.on('resetPoint', msg => {
        ball.position.set(0, 0, 0);
        senX=-1;
        senY=-1;
        ballSpeedX = 0.05;
        ballSpeedY = 0.05;
        materialTable.color.setHex(0xffffff);
      });

      socket.on('color', msg => {
        switch (msg){
          case 0:
            materialTable.color.setHex(COLOR1);
            break;
          case 1:
            materialTable.color.setHex(COLOR2);
            break;
          case 2:
            materialTable.color.setHex(COLOR3);
            break;
          default:
        }
      }); 
    </script>
  </body>
</html>